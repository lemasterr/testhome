# Лабораторна робота 9. Колекції в Java

## Цілі лабораторної роботи:
- визначити призначення колекцій та сценарії їх використання;
- вивчити призначення інтерфейсу `List` та особливості реалізації цього інтерфейсу;
- вивчити призначення інтерфейсу `Queue` та `Deque`, а також особливості реалізації цього інтерфейсу.
- вивчити призначення інтерфейсу Set та особливості реалізації цього інтерфейсу;
вивчити призначення інтерфейсу Map, а також особливості реалізації цього інтерфейсу.


## Хід роботи

### Завдання 1

Реалізуйте метод `removeShorterStrings()`, який приймає `List<String>` і видаляє з кожної пари рядків, рядок з меншою довжиною.

Наприклад, для списку:

`{"four", "score", "and", "seven", "years", "ago"}`

перелік пар буде таким:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод повинен знайти рядок з меншою довжиною з кожної пари рядків та видалити його. В результаті, метод повинен змінити список наступним чином:

`{"score", "seven", "years"}`

Якщо рядки в парі будуть однакової довжини, метод повинен видалити перший рядок з пари.

Якщо список буде мати непарну кількість елементів, метод повинен залишити останній елемент без змін.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 2

Реалізуйте метод `stutter()`, який приймає `List<String>` та дублює кожен рядок у списку.

Наприклад, якщо метод приймає на вхід список:

`{"how", "are", "you?"}`

то вхідний рядок повинен бути змінений наступним чином:

`{"how", "how", "are", "are", "you?", "you?"}`

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 3

Реалізуйте метод `switchPairs()`, який приймає `List<String>` та попарно змінює елементи місцями.

Наприклад, для списку:

`{"four", "score", "and", "seven", "years", "ago"}`

перелік пар буде:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод повинен змінювати елементи місцями в кожній парі чисел. В результаті метод повинен перетворити список наступним чином:

`{"score", "four", "seven", "and", "ago", "years"}`

Якщо список буде містити непарну кількість елементів, метод повинен залишити останній елемент списку без змін.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 4

Реалізуйте метод `removeDuplicates()`, який приймає `List<String>` та видаляє із списку дублікати (**рядки у списку будуть відсортовані**).

Припустимо, є такий вхідний список:

`{"be", "be", "is", "not", "or", "question", "that", "the", "to", "to"}`

Метод повинен перетворити список наступним чином:

`{"be", "is", "not", "or", "question", "that", "the", "to"}`

Так як список буде відсортований, то дублікати будуть згруповані разом.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 5

Реалізуйте метод `markLength4()`, який приймає `List<String>` та додає рядок `****` перед кожним рядок із 4 символів.

Припустимо, є вхідний рядок:

`{"this", "is", "lots", "of", "fun", "for", "every", "Java", "programmer"}`

Метод повинен перетворити рядок наступним чином:

`{"****", "this", "is", "****", "lots", "of", "fun", "for", "every", "****", "Java", "programmer"}`

Зверніть увагу на те, що оригінальні рядки з 4 символів не змінюються та не видаляються, а залишаються у списку. Рядок `****` додається перед рядком з 4 символів, а не замінює його.

**Метод повинен виконувати роботу у вхідному списку та не використовувати додаткових структур даних для збереження проміжних результатів**

### Завдання 6

Напишіть метод `isPalindrome()`, який приймає в якості вхідного параметру `Queue<Integer>` та повертає `true`, якщо числа в черзі представляють собою паліндром (та `false` у іншому випадку). Послідовність чисел вважається паліндромом, якщо вона однакова у прямому та зворотньому порядку.

Наприклад, припустимо, що є черга `q`, яка зберігає такі дані:

front `[3, 8, 17, 9, 17, 8, 3]` back

Виклик методу `isPalindrome(q)` повинен повернути `true`, тому що ця послідовність однакова у прямому та зворотньому порядку. Якщо б черга зберігала такі значення:

front `[3, 8, 17, 9, 4, 17, 8, 3]` back

Виклик методу `isPalindrome()` замість цього поверне `false`, тому що ця послідовність не збігається у зворотньому порядку (9 та 4 у середині не збігаються).

Пусту чергу слід вважати паліндромом.

Ви не повинні робити ніяких припущень стосовно того, скільки елементів знаходиться у черзі. Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стеку для вирішення цієї задачі.

**Додаткове завдання** Реалізуйте метод таким чином, щоб вхідна черга за результатами роботи методу залишилась в тому ж вигляді, в якому вона була на початку роботи методу.

### Завдання 7

Реалізуйте метод `reorder()`, який приймає `Queue<Integer>` у якості параметру. Вхідна черга відсортована за зростанням **абсолютного значення** числа. Приклад такої черги:

front `[1, 2, -2, 4, -5, 8, -8, 12, -15, 23]` back

Метод `reorder()` повинен **змінити вхідну чергу** (метод не повинен створювати нові черги та повинен повертати `void`), щоб вона була відсортована за зростанням з урахуванням знаку числа.

Для прикладу вище, метод `reorder()` повинен змінити значення місцями таким чином, щоб черга мала наступний вигляд:

front `[-15, -8, -5, -2, 1, 2, 4, 8, 12, 23]` back

Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стеку для вирішення цієї задачі.

### Завдання 8

Реалізуйте метод `rearrange()`, який приймає на вхід `Queue<Integer>` у якості параметру та змінює порядок значень таким чином, щоб всі парні значення з'являлись перед непарними значеннями, зберігаючи порядок слідування парних та непарних значень між собою.

Наприклад, припустимо, що черга `q` зберігає таку послідовність значень:

front `[3, 5, 4, 17, 6, 83, 1, 84, 16, 37]` back

Виклик методу `rearrange(q)` повинен змінити порядок елементів черги наступним чином:

front `[4, 6, 84, 16, 3, 5, 17, 83, 1, 37]` back

Зверніть увагу, що всі парні числа з'являються на початку черги, за якими йдуть непарні, та порядок парних чисел є таким ж, як у вихідній черзі, че ж стосується і непарних чисел.

Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стеку для вирішення цієї задачі.

### Завдання 9

Реалізуйте метод `maxLength()`, який приймає `Set` рядків та повертає довжину найдовшого рядка у множині. Якщо буде передана пуста множина, метод повинен повернути `0`.

Наприклад, якщо подати множину `("one", "two", "three")`, то метод повинен повернути `5` - довжину рядка `three`.

### Завдання 10

Реалізуйте метод `removeEvenLength()`, який приймає `Set` рядків та видаляє із множини усі рядки парної довжини.

Наприклад, якщо передати методу множину

`("foo", "buzz", "bar", "fork", "bort", "spoon", "!", "dude")`

то метод повинен повернути множину

`("foo", "bar", "spoon", "!")`

### Завдання 11

Реалізуйте метод `numInCommon()`, який приймає на вхід два списки цілих чисел у якості вхідних аргументів та повертає кількість унікальних цілих чисел, які зустрічаються в обох списках. Для розв'язання данного завдання рекомендується використати множину цілих чисел у якості допоміжної колекції.

Наприклад, якщо перший список містить наступні значення

`[3, 7, 3, -1, 2, 3, 7, 2, 15, 15]`

а другий список містить наступні значення

`[-5, 15, 2, -1, 7, 15, 36]`

то метод повинен повернути 4, тому що елементи `-1, 2, 7, 15` зустрічаються в обох списках.

### Завдання 12

Реалізуйте метод `isUnique()`, який приймає `Map<String, String>` у якості параметру та повертає `false`, якщо хоча б два ключі відображаються на одне і те ж значення та `true` у іншому випадку.

Наприклад, для даного відображення метод поверне `true`:

`{Marty=Stepp, Stuart=Reges, Jessica=Miller, Amanda=Camp, Hal=Perkins}`

Для даного відображення метод поверне `false`, тому що в колекції повторюються значення `Perkins` та `Reges`:

`{Kendrick=Perkins, Stuart=Reges, Jessica=Miller, Bruce=Reges, Hal=Perkins}`

Пусте відображення вважається унікальним, тому метод повинен повернути `true`.

### Завдання 13

Реалізуйте метод `intersect()`, який приймає на вхід два екземпляри `Map<String, String>` та повертає новий `Map`, який є перетином двох вхідних.

Перетином двох відображень є таке відображення, яке включає пари ключ-значення, які присутні в обох вхідних відображеннях.


Наприклад, для даних вхідних відображень:

`{Janet=87, Logan=62, Whitaker=46, Alyssa=100, Stefanie=80, Jeff=88, Kim=52, Sylvia=95}`

`{Logan=62, Kim=52, Whitaker=52, Jeff=88, Stefanie=80, Brian=60, Lisa=83, Sylvia=87}`

Метод поверне наступне відображення:

`{Logan=62, Stefanie=80, Jeff=88, Kim=52}`

### Завдання 14

Реалізуйте метод `reverse()`, який приймає `Map<Integer, String>` та повертає новий `Map<String, Integer>`, у якому всі ключі та значення змінені місцями: в парі "ключ-значення", значення переходить на місце ключа, а ключ - на місце значення.

Якщо виникне ситуація, коли в оригінальному Map є пари з однаковими значеннями `(k1, v)` та `(k2, v)`, то в новому `Map` в можете виключити любу з пар
`(v, k1)` чи `(v, k2)`.

Наприклад, якщо є оригінальний `Map`

`{42=Marty, 81=Sue, 17=Ed, 31=Dave, 56=Ed, 3=Marty, 29=Ed}`

то метод повинен повернути такий `Map` (порядок не має значення):

`{Marty=3, Sue=81, Ed=29, Dave=31}`

### Завдання 15

Реалізуйте метод `rarest()`, який приймає `Map<String, Integer>` та повертає значення, яке зустрічається в `Map` найбільш рідко.

Якщо є декілька значень, які зустрічаються з однаковою частотою, то метод повинен повернути найменше значення (значення у вхідному `Map` є цілими числами).

Наприклад, якщо метод приймає на вхід наступне відображення:

`{Alyssa=22, Char=25, Dan=25, Jeff=20, Kasey=20, Kim=20, Mogran=25, Ryan=25, Stef=22}`

то метод повинен повернути `22` (тому, що це значення зустрічається тільки два рази, значення `25` зустрічається чотири рази, значення `20` зустрічається три рази).

Якщо метод приймає на вхід таке відображення:

`{Alyssa=22, Char=25, Dan=25, Jeff=20, Kasey=20, Kim=20, Mogran=25, Ryan=25, Stef=22, Kelly=22}`

то метод повинен повернути значення `20` (значення `22` та `20` зустрічаються по три рази, але `20` менше за `22`).

### Завдання 16

Реалізуйте метод `maxOccurrences()`, який приймає на вхід список цілих чисел у якості вхідного аргументу та повертає, скільки разів зустрічається найпоширеніше число у списку.

Наприклад, якщо на вхід поступив такий список:

`[9, 7, 9, -1, 2, 9, 7, 2, 15, 15]`

то ваш метод повинен повернути `3`, тому що найчастіше всього у списку зустрічається число `9` та воно зустрічається у списку три рази.

Для рішення даної задачі рекомендується використати відображення у якості допоміжної колекції. Якщо вхідний список є пустим, то метод повинен повернути `0`.
